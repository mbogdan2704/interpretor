Maria Costin Bogdan 

Am facut doar evaluarea.
Pentru inceput, am creat un tip de date, Result, care are patru constructori.Acest tip de date va fi rezultatul functiei de evaluare pentru expresii, prin urmare acest tip de date trebuie sa aiba un constructor prin care sa specific faptul ca rezultatul este o valoare, o eroare(de neinitializare), sau un boolean, pentru "<" si "==".Apoi, mi-am dat seama ca trebuie sa salvez intr-o structura de date variabilele pe care le-am initializat, prin urmare am definit un dictionar(care are un String si un Int), si o metoda pentru acesta, care imi cauta in dictionar o variabila data ca parametru. Daca aceasta exista se intoarce valoarea ei, in caz contrar se intoarce o eroare. Urmeaza functia de evaluare pentru expresii, facand pattern matching pe fiecare expresie. Pentru Value, trebuie sa intoarcem un constructor care tine salvata valoarea x.Pentru symbol, trebuie sa returnam valoarea care se afla in dictionar atribuita acestui simbol. Pentru plus, am evaluat partea din stanga, partea din dreapta, si apoi am returnat valoarea adunata, doar daca niciuna din cele 2 functii nu returneaza un error.Pentru mult si sub este asemanator. Pentru Equal si Smaller am facut evaloarea din stanga si din dreapta, si apoi am vazut daca conditia este adevarata, returnand TTrue sau FFalse. Apoi, urmeaza evaluarea de assign-uri, care imi returneaza mie un dictionar obtinut prin concatenarea parametrului.In cazul in care functia de evaluare intoarce Error, inserez in dictionar un string specific. Urmeaza functia de evaluare pentru programe, unde fac pattern matching pe fiecare program in parte. Fiecare functie in parte intoarce dictionarul, astfel eu o sa am dictionarul actualizat in fiecare functie. Pentru Seq tot ce trebuie sa fac e sa evaluez partea din stanga si partea din dreapta. Pentru Eq trebuie sa fac assign-ul. Pentru Return, fac evaluarea expresiei, dupa care vad daca este Error.Daca este Error, inserez string-ul specific in dictionar, in caz contrar inserez in dictionar tot un string specific, "return". Pentru if, fac evaluarea expresiei, iar in functie de rezultatul ei(poate fi TTrue sau TTFalse) apelez evaluarea pentru primul program sau pentru al doilea. Pentru for, fac in prima faza primul assign(gen i == 0), dupa care apelez o functie auxiliara(evalFor). In acesta functie apelez programul pana cand conditia nu mai este adevarata. Pentru assert verific daca conditia este adevarata, iar in caz contrar introduc stringul "assert failed" in dictionar. Functia principala, evalAdt, imi apeleaza functia de evaluare pentru programul intreg, dupa care fac 3 filter, ca sa vad daca am erori. De exemplu, caut string-ul "assert failed" in dictionar. In cazul in care length n este diferita de 0, asta inseamna ca in dictionar este un assert failed, prin urmare Returnez Left eroare. Daca nu am nicio eroare, returnez un Either String Int, care va fi un Right(pentru ca nu e eroare) valoare, unde valoare este ce numar se afla in dictionar atribuit unui return.Am facut acel reverse pentru ca poate exista cazul in care exista mai multe returnuri, iar eu trebuie sa returnez primul return.
